'''
Generated by ChatGPT 4o, modified by Daniel.  
maybe: remove `ARCHIVE_FILE` entries if local file not found?  
'''

import subprocess
import os
import json

# from my_secrets import PLAYLIST_ID, PLAYLIST_NAME

LIKED = 'LIKED'

PLAYLIST_ID, PLAYLIST_NAME = LIKED, 'liked/songs'

ARCHIVE_FILE = 'downloaded.txt'
EXT = 'mp3'

LIKED_LIST = '../good_music_ids.txt'
LIKED_META = '../meta-enriched.jsonl'

def download():
    if PLAYLIST_ID is LIKED:
        cmd = [
            'yt-dlp',
            '-x', '--audio-format', EXT,
            '--embed-metadata', '--embed-thumbnail', '--add-metadata',
            '--download-archive', ARCHIVE_FILE,
            '-o', ' - %(title)s [%(id)s].%(ext)s',
            '-a', LIKED_LIST,
        ]
    else:
        url = f'https://www.youtube.com/playlist?list={PLAYLIST_ID}'
        cmd = [
            'yt-dlp',
            '-x', '--audio-format', EXT,
            '--embed-metadata', '--embed-thumbnail', '--add-metadata',
            '--download-archive', ARCHIVE_FILE,
            '-o', ' - %(title)s [%(id)s].%(ext)s',
            url,
        ]
        print(f'Running yt-dlp to sync: {url}')
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        print()
        print('subprocess.CalledProcessError')
        print(e)    # likely some videos are not available
        print()
        # print('Continue? Ctrl+D to stop; Enter to continue.')
        # input()

def getPlaylistEntries() -> list[tuple[str, str]]:
    if PLAYLIST_ID is LIKED:
        with open(LIKED_META, 'r', encoding='utf-8') as f:
            entries = []
            for line in f:
                d = json.loads(line)
                entries.append((d['id'], d['title']))
            return entries
    else:
        result = subprocess.run(
            [
                'yt-dlp', '--flat-playlist', '--print', 
                '%(id)s\t%(title)s', 
                f'https://www.youtube.com/playlist?list={PLAYLIST_ID}', 
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            encoding='utf-8',
            check=True,
        )
        entries = []
        for line in result.stdout.strip().split('\n'):
            if '\t' in line:
                video_id, title = line.strip().split('\t', 1)
                entries.append((video_id, title))
        return entries

def renameLazy(src: str, dest: str):
    if src != dest:
        print(f'Renaming: {src} -> {dest}')
        os.rename(src, dest)

def cleanTitle(title: str) -> str:
    allergy = r'<>:"/\|?*'
    x = title.strip()
    for c in allergy:
        x = x.replace(c, '_')
    return x

def reindexFiles():
    '''
    For when the playlist changes order.  
    '''
    print('Reindexing files...')
    entries = getPlaylistEntries()
    remaining_local_files = set(os.listdir('.'))
    n_digits = len(str(len(entries)))
    for index, (video_id, title) in enumerate(entries, start=1):
        matches = [x for x in remaining_local_files if video_id in x]
        try:
            src, = matches
        except ValueError:
            assert matches == [], 'OMG multi match???'
            print(f'[skip] {video_id} not found locally.')
            continue
        remaining_local_files.remove(src)
        _, ext = os.path.splitext(src)
        padded_index = str(index).zfill(n_digits)
        renameLazy(src, f'{padded_index} - {cleanTitle(title)} [{video_id}]{ext}')
    for fname in remaining_local_files:
        if not fname.endswith(EXT):
            continue
        keyword = 'zombie'
        if fname.startswith(keyword):
            continue
        renameLazy(fname, 'zombie - ' + fname)

def main():
    os.chdir(PLAYLIST_NAME)
    download()
    reindexFiles()
    os.chdir('..')

if __name__ == '__main__':
    main()
